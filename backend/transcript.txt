good morning everyone how are we all
going
um just making sure i've made some
settings changes on my streaming
software
because the last couple of lectures i
was getting some crashes happening
near the end of the time so just making
sure everything's okay
it seems to be just looking at all of my
stuff over here
seems to be streaming okay um
let me know if anything goes weird um
hopefully the
um it's it's a lot of stuff with like
the screen resolution
and the the video streaming so hopefully
there's no problems there and we're all
okay
yeah people saying the audio is good
which is good
someone's saying they're tired yes
i i do fully understand that
week 8 is a is a tired time where um
we're all pushing through to the end of
term
um i sent out a notice yesterday
i didn't send out the usual notice on
monday because i wasn't even in sydney
on monday actually i was actually taking
a long weekend
um but um the
second assignment has been released
there's a couple of things i want to
talk about second assignment has been
released
um so the core section of the second
assignment is available now to do
um as far as i remember the auto tests
are now up and running
they're either going to be up and
running today or they're up and running
yesterday
so pretty soon and like the the version
of the assignment because we released a
draft version i think on sunday or
monday
um and then we had a quick look and
finalized it and now
the the version's up there now is the
one they're actually going to be working
on
um we've also been given the time for
our exam
it's very awkward it's all good for us
as well because we have to work on the
weekend for the exam
um which is going to be on saturday
if i remember correctly it's the
first of may i think so
you know it's not it's not ideal and i
know it's not ideal for this to be a
saturday
exam but um we put some queries in
about the scheduling of the exam uh but
basically i think with the
just the sheer number of subjects and
the number of people
in subjects at unsw at the moment
weekend exams are happening
which i know is not amazing um
but i think it's a matter of it being
if you're trying to squeeze thousands of
students together into like a two-week
exam period some people are going to end
up having to be on the weekends
and it's sort of going to be a luck of
the draw of how often you're going to
end up with weekend exams hopefully most
of the time you won't have to do weekend
exams
but this time for one five one one
unfortunately we have to do the weekend
exam
um at least it's a take-home exam i will
tell you more i actually have a whole
lecture
on the exam structure and format which
will be in week 10 so
i don't want to go into it too much
right now but um
you don't have to come into unsw to do
the exam i mean many of you
are um not even
able to get to sydney at the moment
because we've still got a whole lot of
closed borders around the world
due to covert 19 so um
the exam will be basically done on your
own computer
at home and it will actually be quite
similar to
doing things like lab exercises or your
assignment and things like that
where you will do some questions we give
you and then submit them to us
and then we do the testing and things on
our end
um or someone said it's right after the
maths exam
is that that that's kind of awkward
because that's like
is that probably two really big core
subjects happening at the same
like one day after the other at least
you know you're all in the same boat
so so all of your marks are going to
like nearly everyone is doing the same
two subjects
all your marks will drop the same amount
and then us as the lecturers will have
to be like oh
look at that the whole course has
dropped like a five percent average
maybe we bump it up or something it
depends depends on the situation um
someone said the exam timetable still
says we have to consult the school for
times
yes so um we're running the exam
ourselves rather than it being a central
unsw
run exam which means that
we will let you know exactly when in the
day
it is last term we ran
i think sydney time 1 p.m to 7
p.m i think it was a six hour thing but
i'm not making any promises about that
yet because
a we've just shifted an hour for
daylight savings what we usually do is
we figure out when the time zone works
for all international students and
and set it at a good time like that
but we haven't done that organization
yet so i'm not going to say anything
about how long the exam is or exactly
when it is
but we've set it up as an afternoon exam
so it's going to be sometime in the
second half of the day
cameron asked is it a two-hour exam no
it is not it's much longer than two
hours
as much as like it is possible to finish
the exam in a short amount of time we
give people longer because we can't
guarantee
um you can't guarantee that there won't
be technical difficulties and stuff like
that so we tend to put like a big buffer
time on the exam so that if anyone's
computer crashes or something like that
and any of those things that might
happen if it was happening in our
computer labs if we ran the exam in our
computer labs
and someone's computer crashes um we
note down that person we give them like
15 minutes extra at the end that kind of
thing
but since we can't do that we just
basically do a big buffer so the exam
can just go for longer
and if anyone has any hardware issues
and stuff like that it's all sort of
built in
to what what the extra time is the exam
gives you so
i'm not going to say anything more about
the exam we're going to cover a lot of
lecture time
on the exam later um
so i will um i'll talk about that when
we actually finalize stuff so
it's not really worth me talking about
now other than we know exactly which day
it's on
so if i remember correctly first of may
i know there's a five and a one in the
dates i assume it's first of may
if it's the fifth of january that will
be very weird and you'll have forgotten
most everything by then but anyway
let's um let's go into what we're
talking about today
because we have work we want to do today
and i've got time dedicated to the exam
later so what did we learn last week um
hope
everyone had some time life off over the
long weekend
but i hope also that you haven't
necessarily forgotten everything that we
were talking about
uh last week so we piled on a few topics
last time but they're all kind of linked
together which is the um
structs and memory allocation we're
working on which was our ability to
create
custom variables made up of
other other variable types so it's kind
of like
a container for other variables i use
the bento box example
is like a a lunch box that has little
different sections in it for different
types of food
so as opposed to something like an array
which only stores one type
of a variable a struct can store custom
amounts of other types of variables
and can even store stuff like arrays as
well so it's kind of like
an umbrella container that can contain
other
variables and we saw how useful that
could be if i just jump down here to
link
lists where if i made a struct and i had
it
carry a pointer to its own
type then we ended up with the
capability of
joining these structs together
and we thought of them as nodes in a
list we also had a quick look at
multiple file projects
um so we did a very very quick demo of
how you link together
um an h file and a c file and a main
file and we kind of looked at
how our single file projects up into
this point
were kind of like this already they had
a header at the top which had stuff like
function
function declarations and things like
that we had our main which is just the
body of the main function
but then we also had um below the main
function
all of the other um actual
code for the functions and if we split
those three sections apart
into three different files that's kind
of what our multi-file project
is so it's kind of like we were working
with all these concepts already
but once we start to organize them it
gets easier to read what we're doing
and it gets easier to um to
organize and separate our data in a
sense
um so questions i should not have said
stuff about the exam
i was um
i think michael will have to answer all
the questions about the
um the exam that are coming up but don't
worry like there's not that much
uh information there ziji that is very
very mean
so i'm asking what people got in the
midterm exam last week
that was an april fool's joke for last
week so it's only if you happen to be
here on april 1st
i made a joke that there was a midterm
exam and like i made it really really
harsh as well i made it like oh it's
coming out this afternoon and it's due
tonight
uh so that was just a joke don't worry
about it um
i laughed a lot but that's the most
dislikes that i've gotten
on a lecture before so i thought it was
pretty funny
okay so talking about what we did last
week so structs memory allocation
we had a quick look at multiple file
projects and then we started building
linked lists
the other thing i think that will be
interesting to look at is checking out
the assignment files because the
assignments are pre-made
multi-file project and i was talking
about the difference between
working on say the main in in a project
and working on a c file in the project
where neither one necessarily knows what
the other one's doing but in between the
twos it's an
h file that is what we call an interface
and that defines
what both of them should be doing in a
sense
in the assignment you will be just
implementing functions
in the c file and those functions will
be
defined in advance as having very very
specific inputs and outputs
as well as specific purposes that
they're supposed to be doing
so you'll you'll get a a glimpse at what
it's like to
actually work in a group where someone
else is working on the main files and
you can look in the main files and see
what they do
but you don't actually have to use them
so for the moment we've just got three
files which is good
so it's the same kind of setup as that
the batman example that i did previously
but if we if you get into the extension
you want to do more we're going to
release
more files and you'll see other ways of
connecting together multi-file projects
okay so what are we doing today so
um last
last week we started working on linked
lists and
we were doing the the battle royale
example
that i was working on where i think
where we got up to last time was we were
able to just build a list
of players and print it out which is
which is a good start because what we
really want to do at the beginning is
just
get the grasp of what link lists do
but today we're going to be continuing
on that by
adding more parts to this to this
project
i was actually thinking about splitting
this up into a multi-file project at
this point
um especially because we've already done
stuff like a type def and stuff so we
might actually do that
i don't know if i'm going to eat up too
much time by doing that but we'll see so
we were building a list and we were able
to loop through it to print it out so
today what we're going to do is we're
going to look at adding
to linked lists so we're going to look
at the the theory behind you know
if we have an array and we try to insert
something in the middle of the array we
have a really weird issue
because there's no space in between
elements in an array
so if i want to insert something i'd
have to grab everything in the array
shifted along and then
insert something which involves looping
through and copy and pasting
all the way through that kind of thing
um
so it's a bit awkward but a link list
can just shift a few pointers around
and insert something i will draw some
pictures and show some pictures and
stuff like that for this because
um personally i think it's much easier
to
think about the theory of linked lists
visually
you still do need to do the code though
so you still need to translate into code
and a whole lot of this is about
understanding how
moving pointers works so if i want to
change where a pointer is aiming
then what i'm going to do is change the
address that it stores
so it's a combination of knowing that we
can
assign values to variables and assigning
a value to a pointer
is changing where it's aiming but we'll
do all this visually as we're going
through it
so quick recap
what is it linked list
[Laughter]
sorry i just i just love this guy so
funny i wanted to um
at some point um pick up
a leopard print suit and stuff and and
and do a cosplay of um pineapple pen man
so a recap of what linked lists are
this is the key struct that gets us
um that gets us the link list
the important point is a pointer
to its own type which allows us to link
them together
in a chain we can also carry some
information
and depending on what we want to do
we'll carry more or less information so
if you've had a look
at the um at the second assignment um
you'll notice that
we're we're building music in the second
assignment in a sense like it's
it's kind of um you can't quite hear it
although there is a program that lets
you hear some of it
um but it's the ability to chain
notes together in a linked list so what
we have here
is just an integer for data but even in
our example for battle royale we've got
strings in here
and this struct is not limited to
carrying only one piece of information
you could put many variables in there
oh people are reminding me how old my
meme is yes
um pineapple pen is i guess a dated meme
now
but but he's just so funny i can't i
can't let him go
all right so visually
this is what we're getting at when when
we we see a linked list
so every node in the linked list
is contained in its own piece of memory
so every struct
is its own piece of memory it's not
necessarily connected to any of the
others
but every node in the list has a pointer
in it
which stores the address of the node
that comes after it in the list
so this next pointer stores the address
where this piece of memory starts
and when we're thinking about it
visually whenever we make a pointer in
something we usually just draw an arrow
to wherever it's aiming at so this node
knows that there's another node and that
each of them carries some information
so if it's just an integer yeah it's
data but um
could be strings could be arrays of
things could be a whole lot of stuff
um could even have other pointers to
other things you know so
um the
there's no real limitation on what you
can store in a struct
i guess the only limitation is the soft
limitation which is the meat brain
limitation
of how much you can um
how much you can actually keep
understanding and that's really based on
how well you write your code
uh whether someone can understand your
complicated uh four-dimensional linked
list
with with with pointers going back and
forth through the list and other stuff
like that
um that's a joke at the moment but it
won't be a joke later real things like
that do exist and a lot of us have
worked with
very very strange extensions of this
concept
there's a great deal of computer science
that stems from this basic concept
of i have this thing with some
information
and then i have a pointer that leads to
another thing that's identical
in type but has some other information
so we go from
this list of things that are joined up
to like these
weird spanning graphs of things and then
neural networks and all this kind of
stuff right
we'll talk about that later well we
probably won't because com1511s are not
going to go that deep we need to get the
basics
we need to understand them first it's
hard enough
as it is in a single line uh let alone
when it gets big
but you know there's plenty of time to
learn that later
yeah they were talking about what the
hardware aspects of their brain are
um the brain's really weird very weird
process let's not talk about that now
there are there are some very strange
things that the brain does
so one of the last things that we did
last week was we're looking at looping
through the link list and printing it
out
i'll jump into the code in a second um
the trick with the loop through linked
list
is i think mostly the
the structure is not thinking about
the end of the list being the number of
elements in the list
because a linked list even more than an
array is not necessarily going to have
the same number of elements
and it's going to change in its number
of elements a lot so instead of
uh instead of it being looped through a
specific number of times
it's very much more of the loop through
until there's nothing left
and this is actually really similar to
the loops we're doing on strings
where the strings just loop because they
don't know how long they are
but when they hit the null terminator
they stop in the same way
that the um a loop through a linked list
keeps going until the pointer that it's
moving through the list
is null and if the pointer is null
it means that um we've gone off the end
of the list and we're no longer
aiming our node pointer at a node
anymore we're only aiming at the empty
space off the end of the list
and so when we get that um we
we say okay there's no more to do in
this list and the other thing that we do
is the way that we move through the list
is we follow these next pointers so i
say i do something with this node
and then i follow the next pointer and i
get to this node follow the next pointer
get to this node follow the next pointer
here follow the next pointer here to
null and that's where we stopped
so what we're going to do is we're going
to maintain one pointer
that changes its address to each node in
turn so the first
the first time through the loop it's
pointing at the first node and then it
says okay i'm going to copy this address
because if i copy this address that
leads me to this node and i store that
address in my pointer and i move on to
the next
which is this line of code here i think
personally the most confusing thing
about linked lists
is going from this image
and thinking about moving pointers
around in this image to like a single
line of code
like this where you go how does this
move the pointer
right and this goes back to what i was
saying earlier the moving pointers
is about changing their value so if i
have an address so i've got a piece of
paper that i've written down an address
so
150 anzac parade 150 anzac parade says
to me
all right the next house you need to go
to is at 200
anzac parade i'm just making these
numbers up by the way apologize if
anyone actually lives there
i'm just using your houses as examples
so it says all right the next one is go
to 200 anzac parade
so what this line of code does it says i
read the 200 anzac parade
from the place i was looking at and then
i say to my address okay i'm going to
rub that out
and now i'm going to write 200 anzac
parade there and then the pointer that
i'm holding the piece of paper
then becomes a different address and
it's now aimed at a different location
so there's a bit of going back and forth
between
knowing how these
knowing how visually a linked list
should work
and then getting pointers to move around
so we're gonna get a prac bit of
practice with this
you've already if you've had your
tutorial this week so anyone who has
yesterday has had a little bit of
practice on this
um later tutorials will um
we'll we'll get to see a little bit more
of this in the lecture before they go in
so
there's a bit more about inserting here
that you may use
for the moment we've only inserted
something at the very start of the list
so we've shown a really simple way of
doing that but today we're going to
start inserting at other points
[Music]
oh lorenzo is asking does head next next
work as a pointer to the third element
of the list
yes it does if it exists you can do
stuff
like that and there actually isn't a
limitation to how many next next next
you can have because if you think about
going into this struct
and you go to the next it takes you to
another one of these which means there's
a next inside that
which takes you to another one of these
and there's a next inside that so long
as it's
built correctly and there's actually
data there for you to go to
you can do that once you hit the null
things get weird though right because
you've got to actually check
that's why saying um
like head next next next next next might
be super dangerous because you don't
know at that point in time whether your
list actually has stuff in it
which is usually why we loop through one
at a time checking for nulls along the
way
okay so where we're up to um
let me log in
just in case anyone needs it
we now have this web address here i
don't know if you can see that looking
at my screen over there
unlikely that you can see that but the
link is as usual in the lecture section
on the web page
all the moment we have in here is the
battle royale.c which is where we were
up to
last time
which is this so
sorry this one's not a joke but um
so we had our node which was
a player
node that just contained the name of the
player so we're keeping it reasonably
simple at the moment we're still only
keeping one variable in these
but if i wanted to you know it's pretty
easy to edit this and say okay i want to
keep score
or something or i could have
i don't know um
i'm just like making up stuff right
because like not many games necessarily
keep score of a lot of things but they
might keep inventory or something like
that
so you know famous battle royale games
if i'm gonna do something like fortnite
i would potentially want to know what
um what items a player is carrying so
when they get knocked out of the game
um they drop their right wait do they
drop items in fortnite
i don't even know i don't really play it
okay
so but i know like a pubg player unknown
battleground so you can steal stuff off
people
after you take them out so anyway we
could have some more information here if
we wanted to
so but that's okay for the moment with
we're thinking about the structure of
the linked lists and stuff like that
um okay
we had some functions as well we have a
typedef here so we're thinking
if we want to think of this thing not as
a pointer if we want to think of it just
as a
concept so that we don't accidentally
dip into here and cause
issues we can do capital p player so if
i want to start
splitting this up into
into different files
could create a main.c and what i'm going
to
do is i'm going to take my main
here i did ctrl x there to cut that
and put it in here i know that it is
going to need to
include
an h file so i'm going to call it
battleroyal.h
assuming that i'm going to create that
so let's just create that now
and in the h file the h file is going to
have
some of these important things like the
hash defined
our type def is going to go in there as
well
and our function definitions
are going to go in there also we
probably don't need something saying
functions in here
create a player by
allocating memory
put a comma there populating their data
then returning a pointer to them
a good example of what an h file looks
like
is the h file in the um the first sorry
second
assignment that we have now where the it
has a whole lot of comments in there and
a whole lot of detail on what each of
these things are
but it doesn't actually include
obviously any of the implementation
which we leave in the c file for you to
do
so c file would look a little bit like
this it's got whatever structure is
going to be used
as well as the
actual functions working um i might
actually
take this comment
copy this and put it in the main the
main is usually where you'd want this
but
what i'm going to do is i'm going to put
it in each of them
and say this one's the header file
this is the main file and this is the
implementation
file okay so what i've just done there
is i've separated our
um our initial
single file project into a multifile
project
oh someone just asked when did the last
two lectures get uploaded
my apologies the last two lectures will
get uploaded
when i upload them which means i
obviously haven't done that
so i'm thinking i assume that you're
talking about the echo 360
i think because i haven't copied and
uploaded those so i will get to that
soon
unless you mean youtube in which case
i've made a mistake and i haven't
flicked them over to public and they're
still unlisted
but i'll check on both of those things
afterwards so deluxe are i assume that's
how you
how you pronounce your name um i will
i'll check on that after today's lecture
okay so we're in a situation now where
we have
i'm gonna put the main there and the h
first then the c
sometimes i like them in this particular
order so
the c file has these bits and pieces the
c file is going to need to
also include the h file
or else it won't know which functions
it's
it's creating the h file tells us which
functions there are
um
right so i've got some comments in here
in the header file as well um
the hash define i guess i'll leave it
here in the h file sometimes
some hash defines will go in the c file
some in the h file but might as well
leave it there
okay just to make sure that i haven't
moved anything to the wrong place i'm
just going to check and compile this
whole thing
so remembering when we compile a
multi-file project we compile the c
files and we trust
the c files to include the h file so we
don't need to
compile the h file i'm just going to
change my directory
so that's a bit shorter and i can see
things more easily so i'm going to dcc
the c files that i've got here so if i
have a look at this you can see battle
royale.c
main.c and batteral.h don't worry about
the backup files we're not going to use
them for the moment
unless i accidentally delete something
so i've got my main.c and my battle
royale.c
and the output i'll just call it battle
oops use of undeclared identifier null
all right so i've got a problem here
where i think it's my main
main.c line 14.
um i've got a null in here and because i
didn't have any includes
um to use it then i don't actually have
the capability to use a null i don't
think i'm necessarily going to be using
nulls
once i get deeper into this but i know
that i'm going to need something
for the moment nearly all of the
standard library
um the standard libraries have null
in them but i know that standard lib has
it definitely so
we'll try that okay so we're compiling
let's run it to make sure that it's got
its basic behavior
so goku and chicken mark so remember
each of these insertions
we were doing here was replacing the
start of the list and moving the list
along
so when it prints out it's going to
print out in reverse order
okay so that's where we're up to we've
got two functions
one to create a player and one to print
them out and what we're using
is a simple way of just calling the
create player function
multiple times to add something to the
start of the list
so that's where we're at so far
um i think this is everything this is
the stuff i've already just talked about
yes oh in case you need it you can go
back and look at these things in the
slides but it's in the code as well
yeah so i've just talked through all of
this i don't need to look at those
slides so let's think about what's
next um
what's happening
that's right i think michael's answering
all the questions there okay
so um oh i wonder if i need to talk
about the type
define i think we've talked about this a
little bit but it's probably worth
looking at it so the type define here
um we've got a struct player pointer
that we're now calling capital p player
so
we use player instead of struct player
pointer
so that when we're using it here
in my main that can't see what's in the
c file it can only see what's in the h
file
we can start to think about this as a
concept
of a player rather than a concept of a
pointer to a struct
because there's no point having no point
having a pointer to a struct
if we can't access the internals of the
struct so we don't want
the main file to be able to access the
bits
inside the structs because if you could
that might mean that you'd be able to
change where the next pointer is
in an inner structure then suddenly a
link list would get broken right we
don't want the linked list to get broken
so we want to control what we can do
here
and so for the moment the only thing we
do is create a player and once we've
given it a pointer there's nothing else
that we can do
to edit it so we're kind of protecting
our data in a sense
i'm going to talk more about this later
actually um
next week we're going to do more
building up of these multi-file projects
and the concept of
abstraction which i'll talk about more
later okay
so this is where up to when you think
about what's next
so the next thing we're going to do is
add players to the game so we've already
had the ability to just kind of build up
a list
but that was only at that point allowing
us to insert things at the very start of
the list
so we're thinking about um not just
inserting the start of the list but
inserting anywhere
in a list so we want to be able to loop
to a certain position and then insert
there and then we're going to think
about even better than that
is if we're careful about our list and
we keep inserting in specific places in
our list
what we can do is we can build a list
that's in order
um the idea of creating
batches of data and then keeping them in
specific orders
is something that's like it's pretty big
in computer science because if we can
organize our information it's easier for
us to find things
there's heaps of stuff that we do in
computing which is basically just trying
to make that stuff go faster
so can we find something more quickly
and if we can find things more quickly
than a whole lot of our other parts of
our programs
run faster we're not worried too much
about that in one five
one one one five one one we're trying to
teach you just just how to get things
going
uh not how to make them go really fast
or anything weird like that
um but you will definitely be doing that
later if you if you're gonna continue on
with computing
um so for the moment what we're going to
do is we're going to try to
keep a list in alphabetical order so
what we're going to do is make sure that
every time we insert into the list
it's going in in alphabetical order and
if we can just move through the list and
in certain specific places
we can end up with an ordered list so
first thing that we're going to need for
that
is the ability to insert anywhere in the
list
and then the second thing we're going to
need in the list is to be able to
check where we are in the list and then
insert into it so
a few different things like that today
so the first thing we're going to do
is we're going to insert into the linked
list
doing this involves moving pointers
around
and i just kind of do this like that's
funny as an illustration of the
difference between
what it's like to think about this in
text versus what it's like to actually
think about it
in an image and this is my way of trying
to
um trying to convince everyone to draw
lots of pictures
when you're working with linked lists
and makes it easier so
if we move things next to pointers
around we'll be able to insert something
into the list
so if we have two nodes we want to put a
node in between them we can take the
next pointer of the first node and aim
in our new node
and then we take the next point of the
new node and aim it at the second node
and this is like yeah okay if you if you
kind of know what's going on and
you're really clued in you can
understand what these
what i mean when i'm saying it here but
it's much easier
if we draw pictures instead so here's a
picture of a linked list
before we've inserted anything so this
is a really simple one has a first node
and a second node the numbers are
reversed but you know don't worry about
that
so there's a head into the first node
first node next into the second node
second node next into null well-formed
linked list because they're all joined
together
and the last one um specifically says
okay we finish here
so i want to create a new node i can
create a new node so this one
is calling this one kind of number three
but we're calling this one first node
then second node then new node
so now that i've created my new node
what i want to do is i want my
linked list to still be connected
so i need to connect this new node to
the list and there's a few ways that i
can do that because i do know the
addresses
of the first node in the second node and
i know that the new node is going to
have to slot in
in between these two so the first thing
that i can do
to make this work is i can say okay new
node's next pointer should be pointed at
the second node
and so i say how do i find out where the
second node is
so that i can point new node's next
pointer at it and i go okay
that's that's easy because this thing
used to be connected up well it still is
for the moment it's still all connected
up
so i know that first node points at
second node so what i'm going to do is
i'm going to take
whatever is stored in this pointer and
put it in this pointer
so if i take whatever stored in this
pointer and put in this pointer
i end up with this this pointer now aims
at the same place
so whatever value is in next in first
nodes next
i copied it into new nodes next so new
node is now connected to second node
which is one step closer to this thing
being a complete linked list
however we can never get to new node
because nothing in the link list is
pointing at
the new node so now that i've connected
this up to this i know that it will
continue to the end of the list
so the the tail of the list we call them
head and tail all the time here is
correct
but the first node is not actually
connecting up to the new nodes what i
can say is the next to the first node
should probably point at this new node
so hopefully when i created this thing i
kept its memory address
because if you don't keep its memory
address then you don't know where it is
so now i need to connect this up so i'm
going to say the next of the first node
is going to point at the address of the
new node
and i end up with this so my
new nodes next was set up to be the
second node i had to copy the first
nodes next to do that
which means that i can't do this step
first
because i still need this information
here so that i can make a copy of it
but after i made a copy of it then i can
say the first node's next points that
points at this new node and so if it's
now pointing at this new node
you can see that we've got the head
pointer points at the first node
first node's next pointer points at this
new node which has just been inserted
into the list
this new node's next pointer points at
the second node second node's next point
appoints it null
there we go we now have um
inserted an element into a list um
and it's finished up as
a completely well-formed list
um ooh break time no i don't think we'll
take a break yet
i've got some fun stuff in there bro
i've got some homework for you it's it's
homework it's like fun
homework so i think what we're going to
do
is continue and then when we hit a good
time for the break i'll come back to
that slide
so we've got some code here for
inserting players i'm not going to
talk too much about this slide this is
like way too much code at once
to just talk about so i'm going to
build this code up bit by bit and show
you how it works
so what we're going to do is we're going
to add a function
to our program so the first thing if
we're going to add a function is we're
going to put in the h file so that both
of the other files know what this
function is going to be
um if i remember correctly i was going
to
yes
um insert a
player into a list
after a given
player pointer actually let's
call them capital ps here although this
isn't necessarily
a capital p player this one's a pointer
there you go player nodes i'm going to
keep it really specific what's going on
um i think
i'm going to return
i remember what i'm going to return is
the
oh it's not super specific what i'm
returning here so let's write this
and then i'll think about what i'm
returning afterwards
oh i'll show you something you can do
i put this in brackets like this
when you use this capital todo
to do um it actually highlights it in
your code
so what you can do is actually leave
these in your code for yourself to say
oh
i need to come back and figure out
exactly what this thing is and then come
back
and do it so a lot of the time when i'm
actually working in an h file what i'll
do is i'll plonk
down a whole bunch of functions that i
think i'm going to need and then i'll
put a to-do
in a comment next to each one of them
that i haven't completed yet
or i'll come in here and i'll do
something like this
let me let me write the function itself
so
it's going to return a player and it's
going to be called
insert after
it's going to need
an insert position and then it's going
to need a
name of the new player
i'm going to call it new name again
because we're using new name every time
we're creating a player this thing's
going to need to create a player as well
so this is what i think my function is
going to look like
i mean i'm open to changing this once i
start implementing it but i know that
i'm in
inserting a list after a given inserting
into a list after a given player
so i'm assuming that i've been given a
pointer to somewhere in a list that
already exists
which is appointed to a player and then
i'm going to create a new player with a
given name
and stick them after that player in the
list so i think that this is all the
information i need for this function
so i know what it's called and i think
i'm going to give back
the information about where i inserted
okay so i've got this and i go into my c
file
and i go okay
um and it's going to be a similar
comment i think but i'm going to put a
comment in here anyway
um
sometimes when i get into the c file
there's more detail in there
but what i can do now is something like
this
sometimes i'll just leave it like that
and i'll be like okay i've got to go
back and do that
um and i'll come here and i'll do other
work and stuff but obviously
remember that i'm going to need to have
an insert after function at some point
but then since we're already here and
we're working on this
let's get right into it so
reasonably complicated function i have
talked
briefly about the theory of moving these
pointers around
um but what i would want to do in a
situation like this
is make sure that i've got a good
framework to start with
so again this is the kinds of things i'm
trying to
to help everyone out with is the the
step-by-step process of building this
thing
rather than just typing out the code you
know so i'm going to go through my whole
process
including the to-do's and stuff that i
might do while i'm doing it
so the first thing that i would do is
create the new player
so i'm going to follow these
steps here so i'm going to assume that
i've got a linked list
and i'm going to assume that i was given
a pointer to the first node and i'm
inserting
so let me um
let me draw this so that it's reasonably
clear what's going on
i'll just put in oh wait no i'll i'll
spell it out
i was going to put an x for null so i've
got these two things here
and then let's say
head apologize
for my mouse writing so the head points
here um
i don't know if i'm going to need the
head for insight after but you know
maybe later
at least what i'm saying is this is a
well-formed linked list uh and let's
just
make this
node 1 and node 2. i know they're going
to be names but i'm just numbering them
for the moment
so the first thing i'm going to do is
i'm going to create a new node
uh actually even before that
even before that this function
has been given an insert position so if
it's been given an insert position then
i know that
somewhere i've got a pointer to
something in this list i'm going to make
it a point at a number one to make it
easier on ourselves the first time we
implement this
when we start working with these things
you'll notice things get weird
if you're trying to insert i a into an
empty list
or you're trying to insert into a um
after the end of a list like there's
little fiddly things
we might need to deal with
but i'm going to start with the most
simple example here i guess so we've got
a pointer to the insert there
and we're saying we're going to insert
after this so first step
is we're going to create the new player
then we're going to follow the steps in
the
um in the slides here
i'm going to say first thing we create a
new player second thing we copy the
first nodes next
third thing we move the first nodes next
to the new node and that's it so we're
at this step now we're going to create a
new player
then we're going to copy
the insert positions next
into the new player
then change the
insert positions next to now
aim at the new player
so if i've got these comments in here it
kind of kind of breaks down the problem
for me into a step-by-step thing i can
ignore
these two steps while i'm working on the
first step so
create a new player what would i need to
do to create a new player
this makes it easy on us because we have
a create player function already
so let's say that um
i kind of want to call it new uh but i
think that i should call it
oh i'm gonna call it um
maybe i should just be like you know
sometimes i try to like shrink my
variable name so it's easier for me to
type stuff but sometimes it's like nah
just make it easier to read instead
so i'm going to call it new play i think
i did it up here anyway yeah i called it
new player
in the new player so this thing create
player
returns a player so i know that i can
store the player in new player if i call
create player
and i need to look up here and say okay
what information did the new player need
it needed a name and a next pointer
so the first thing is we give it a name
which is the new name
and then we give it a next pointer which
is kind of cool because
we have another instruction here that
we're supposed to do which was to say
that
insert positions next pointer
is the the next pointer that this
new player should have so we can
actually do both of these things in one
step
so what i'm doing is i'm creating this
thing and i'm
setting up its next pointer to be a copy
of this node's next pointer like this
immediately
so
new one here and when we create it
i'm just going to call it new we'll get
given a pointer to it um so let's just
call this one number three
but the interesting thing about it is as
we create it we can copy number one's
next pointer
copying its next pointer means that this
thing
will aim at the same place that
this one did so we're just copying both
both of them have the same
value in their next pointer
so what i can say is if i'm copying the
insert positions next
i'm going to say insert position and i
know insert position
is a capital p player which means that
especially now that i'm in the c file i
know that
capital p player is the same as a
pointer to the struct
what's in the c file knows what the
struct is so we can access
the fields inside the struct so if we if
we can access the fields inside these
structs
i can say because this is a pointer i
use the pointy accessor to get the thing
inside
and i say take the next pointer
from the insert position and make it the
next pointer
of the new player
so that's me saying look at the insert
positions
actually i'll just use this so you can
see my pointer more clearly
take my insert positions next pointer
which is the data in there that says
next
that gives us access to node number two
and we're going to make a copy of
that here and we've made a copy of that
here which means now this node three
also has access to node two so both of
them have pointers to node two
and i can do that by just saying when
you make this thing make its next
pointer the same as
the next pointer that we can see from
this one
so this is actually
i've shrunk down what i needed to do
there then
what i can do is after that change the
insert positions next to now aim at the
new player so
the the state where it is here
and then what we want to do is this
change
so this first node used to be connected
to the second node but what we're saying
is we're putting the new node in between
the two of them
so we need to link this up like this
in this image here what i'm doing is i'm
saying
we don't need you to connect to this
node over here
anymore
because this one now connects to that so
what we do then is we take
this here this pointer that aims at
number three
and we're going to copy that pointer
into the head
which is going to give it access to this
node here so this new pointer is pointed
at node three
if we copy that new pointer there number
one will now be pointed
at this node here
so change the insertion point as next so
we're changing its
pointer to aim at the new player so if
i'm going to change a pointer
i'm going to take its next oh sorry i
need to say which things
so insert positions next pointer
is now going to be something else so
this is you know using the equals
to change the value of a variable
so i'm going to change the value of this
variable to
the address of new player
and it's really interesting because new
player is a capital p
player capital p player is a pointer to
the struct player so this
is already capital p play is already a
memory address
so all i need to do is just copy
new player because new player is a
capital p player so this is a memory
address
of a player
so i copy that there like that
this is actually all it is for the
insertion which is why i had to spend a
lot of time talking about this
and drawing pictures and stuff because
if i just written these two lines of
code and said dog this is it fine
um you're done i think this would have
been very confusing so
linked lists are really weird like that
where you have to spend a lot of time
thinking about a lot of time figuring
out exactly what you want to do
and then write very very small amounts
of code so it's kind of thing where um
like you don't want to count the number
of lines of code to to
to judge how hard something is because i
would say this is very very hard
but not very many lines of code so we
had to think about where these pointers
were going and how we were setting them
up
and then how we were going to um
uh to to change things to make things
work so
this works for some of the things that
we're doing
so this works if we're inserting in
between
nodes it actually also works if we're
inserting after the two
because if i was inserting say a new
a new node called four
after the two what i would do is
four would copy two's next two's next
point of points at null
so that's a pretty easy copy there and i
would take two's next and then point it
at the four
so i would do this
so we can insert at the very end of the
list like this if we know
obviously this would 2 would be the
insert position there
but we may have some issues if we're
inserting into a list that doesn't exist
this also doesn't give us the capability
to insert at the start
of a list so if i'm inserting after the
head
i always have to be the second element
however we also already had some code
from before to insert at the start of
the list so we've got that if we need
but we do need to deal with the
possibility that this list is empty
before we start inserting so
so if my insert position is null um
that means that there is no list so the
the head of the list is pointing at null
we'd still want to be able to insert
into an
empty list so what we need to do is
before we start
grabbing all these bits and pieces
because
maybe i should i'm going to save that
one
as insertion
just in case if i had the following
so if i had
this is weird right because we haven't
looked at this before this is a linked
list
this is a perfectly valid linked list
the head is pointing into the list
and then the final element of the list
is pointing at null um
so what we're saying here is that it's
empty but it's a working linked list
like we could loop through this i mean
the loop would never run but we could
loop through this
um and we need to be able to work with
these
circumstances so what if my insert
position is this head which happens to
be null
i need to actually check for this
so if
oh sorry we didn't actually do the
the final point which was we're just
going to give back the position that we
inserted into
i wonder if we want to give back the
position we've inserted
or we want to give back a pointer to the
new node that was created
i'm not sure this depends on how we're
going to be using this i am going to
leave that as a to do
because insert after is really going to
be used on its own
we're going to start starting to use it
with other things okay
so the thing that we i wanted to check
for was
if the insert position is null
we're inserting into an empty list so
i'm going to assume that we're setting
into an empty list
because if someone wanted to insert at
the start of
a list they wouldn't give us a null
pointer because giving us null pointer
just gives us access to no list at all
so that that wouldn't allow us to
insert into a list that already exists
and the null pointer
gives us no information so we're
assuming that even
after gets called with a null pointer um
the the program wants us to basically
create
a new list like that so if we're
inserting into an empty list
we're probably still going to do the
same thing we're going to create a
player
but we know that we can't do insert
position
next because if insert position is
not a node it has no next so it's not a
player it has no next so
if i was just to run this function
let's just copy paste this function here
i'm going to cause some serious issues
because this you can't do the next of a
null
so for example um
this doesn't have a next so there is
nothing here the null doesn't have a
next
field so um
let's reopen my last one
where i save it insertion
uh i won't bother saving that one for
the moment
each of these has a next because they
actually nodes that exist
but the null doesn't have a next so we
can't just go
next like that what we can do is say
that if it's an empty list and i'm
adding a node to an empty list i know
that node is the last node
in the list so it will be null
um
so my head
was pointed at null
if i create a new node
i know that it's the only node in the
list because the list was empty
it can be the last node pointing at null
when i point at null and i actually draw
a null on the screen i just want
everyone to remember that it doesn't
exist
null is not a place or a thing i just
happen to be pointing at a thing on the
screen because i have to write null
otherwise it's it's hard to understand
what what that actually means
these pointers are not actually aimed at
the same thing they're both aimed at
nothing
so if i'm going to point that at null
and and this is now the list so i've
just
created i'm just giving them numbers
actually they don't really this this one
doesn't need enough i'm going to leave
the number out
so i've got this and it's pointed at
null so this is my this is my whole list
now so i have a
a pointer to this which is going to be
my new player pointer
and then what i need to do because i
basically just created
a list i might need to give the um the
rest of the program access to this
so when i was inserting here
um into a list that already existed i
didn't have to give back a pointer
to this thing that i'd created because
it was linked up
in the list the insert positions next
was now pointing at it it's all
connected
we don't need to save its address
because we've actually saved its address
in one of the other nodes but this one
there are no other nodes with which to
save the address so what we need to do
is actually give back this
new players
address so i know that
when this finishes i'm going to give
back the insert position
so what i'm going to say is save the new
player's address
in the insert position so that when i
give it back
it's going to say you are inserting into
an empty list i'm going to give you back
a pointer to this new list
that we've created just so that you've
got it
i also want to make sure that this is
the code if i'm creating in a new list
from an empty list
this is the code if i'm adding to a new
a list that already exists
if i'm adding to a list that already
exists i'm only doing one or the other
of these two things
so i don't want to do both of these
things so i'll put them in an if else
like so tab that in
like that and i've got my
return here at the bottom that says
there's a couple of things i was doing i
was either
inserting into an empty list or
inserting to a list that already exists
which i might say here
okay so this is my code that is going to
i don't know if this is even the same as
in the slides it looked like there was
more stuff in the slides
i'll find out later if i've missed
something important but you know that's
coding
we don't expect everything that we
create is going to be correct first go
so i know that if i insert into a list
that already exists
i'm just going to get back the same
pointer that i gave in so it's just it's
just going to say to us
you gave us this position to insert into
we're going to give you back the pointer
saying
okay this is done correctly if we try to
insert to a list that doesn't have
anything yet
we're going to get given back the
address of the thing we just created so
we're going to create the list
like this which is good
okay so we've got our function here uh
it's 1204
though so let's take a break and
and we'll come back and test this
afterwards as well as doing some other
work with it
where's my break wow my break was way
back there somewhere wasn't it
no no
ah here it is okay random homework it's
not really homework um this is more just
like kind of
interesting things that you might get
into if you're interested in computer
science
so a couple of things like you know
there's a lot of fiction in here as well
which is just fun um alphago is real
though
it's a documentary on um youtube
there's a channel called deepmind which
is the um
now owned by google um ai institute i
would call it
that they're working on a lot of things
with um deep learning neural networks
and some of the stuff they're doing is
is trying to
trying to get into spaces where human
intelligence has been kind of pushed to
its peak and seeing if they can compete
at that level
and the game of go is one of those
really interesting documentary
um some short stories about robots and
artificial intelligence
there's other stories about the idea of
like
hacking the human brain or crypt
cryptography and stuff
neil stevenson does a whole bunch of
things which are um
sort of looking at history through a
different lens so it's like sci-fi
but instead of being in the future he
actually looks at at history and changes
things which is quite interesting the
crypto nomicon is one of those
um and sneaks in a lot of stuff that's
real computing as well so i think that's
quite interesting
um human resource machine is a really
funny game on steam i think i've
mentioned this one before
where if you play human resource machine
and then you spend some time with it
and think about it and then you do i
think it's one five
two one or one five three one i can't
remember which
uh no it's one five two one uh the
course um
you'll find that this is the same
language
it actually it may be a game and it's
fun and stuff but it's actually teaching
you assembler
while it's there so it's act it's um the
the stuff you do in the game is an
analog that's exactly the same as the
assembly programming language
um and then i threw in a board game here
which is a board game about
programming your your little player on
the board so instead of like you know
like rolling dice and moving in a board
game
you say i will do this then i will do
this and i'll do this
and then at the end of the phase where
you're picking what you want to do
everyone kind of flips over all their
stuff
and then their player has to act out the
path the sequence that they've
programmed
for the player to do so interesting
little things where you can
you can do some kind of simple
programming and stuff while you
entertain yourself or get inspired about
technology and making technology and
things
so fun little things like that
where um okay so let's go on a break i
think it was 1204 before i started
talking about break time
so let's go on a break it's 1208 now
we'll make it a four minute break so
it's time to come back and do more code
so at 12 past 12 we will come back and
do more coding
alrighty i'm back talking a little bit
about some
playing computer games uh that help with
programming or even just not even help
with programming just like a fun
because of programming or they're um
they're interesting because they take
some of the concepts uh from programming
and make them into
entertaining things so we were talking
before about human resource machine and
the
um the sequel called seven billion
humans but there's like an entire genre
of these games because strangely enough
a significant number of the people
who make computer games are programmers
and so there's always going to be a
significant number of those people
who love programming as much as they
love playing games and they thought oh
why don't we just throw these things in
together
and make programming games so you can
you can check them out i should i know
steam has an entire category of
programming
i can't remember it's called programming
games or just programming
um on steam and then like you see all
these kinds of things and there's some
really interesting stuff in there
um you can check it out if you want so
my homework list is not the only
homework list
i also notice here that it's like books
and games
there are heaps of movies that have um
programming in them as well in different
ways
plenty of them have programming in them
which is like just like hacking the
system and stuff and
and not quite as interesting but some of
them are some of them are more genuine
some of them have actual kind of
questions um
about uh about the nature of you know
controlling machines and stuff like that
which might be interesting
i think war games was a good one old old
movie
1980s um there's a lot of them in the
more recently like i don't know
like i think hackers was a little bit um
and swordfish was a bit like uh
you know so you know
hollywood's always going to be doing
some stuff which is a little bit
weird okay so where are we up
to in our code so
we have created the insert after
function
um but we have not yet tested it to see
whether it works
um
we're talking about
ah people just talking about little
things
like that um someone's saying def con
yeah actually even games like factorio
and satisfactory
like scratch the kind of itch i um i
played satisfactory over new years when
i was on a break
and i think i got to the point where i
was like 16 hours a day in that game and
i was like all right
okay i'm done now i've deleted it since
i've just been like don't go back
to that game especially not if you want
to like keep your job
okay so we've got our insert after and
we know that insert after is here oh
return
specify exactly what the return is good
i can do that now because i've written
it
returns the insert
position or
a pointer to the
new list if it
had been given an empty
list right so now i can specify that i
like the to-do's they remind me of
things
um oh yeah people are talking about
minecraft redstone
um someone was saying that i should do
an entire lecture or an entire course in
minecraft redstone
i thought that would be really funny if
we did something like that and it was
like the
um the attendance to the course wasn't
like a live stream or something like
that it was like you literally hop on
the same server
and then we'd be like all right everyone
get your own little piece of this thing
and build
um build the same thing i'm building
i think that could be quite interesting
i don't know what the server limits are
on those things but
you know okay so if i've got the insert
after function i'm just going to copy
this here
then i may not need this anymore
to create to create a list
so what i could do is instead of create
player
i can say insert after and
the inputs for insert after are the
insert position
and then a name so let's um
[Music]
let's start like this and say okay the
head
is null so we're going to create an
empty list and then we're going to
insert
after and i think this is the other way
around
we're taking the position first
which is the head and then we're getting
the name of the new person that's being
inserted after the head
so here i have insert after taking the
head and then putting me after that
this is not going to change this list
because this is pointed at null so
there's nothing there
to change so what i'm going to do is i'm
going to say
give me back the pointer of the thing
that you've just created which is
me and again get rid of all of these and
and just test this and see how this is
going so hopefully
what we're going to get is i've created
an empty list
i've inserted something into my empty
list and then got given back
the the new list which is which is now
going to be the head and i print this
out
so hopefully this works and it prints
out my
i'm gonna compile this run it
good good start lucky
sometimes i feel like i need to write
more code that doesn't compile first go
because it's um it's a bit unrealistic
to expect all this stuff especially
i just split up into three files and
then added functions and stuff like that
more often than not when you're working
like this you're gonna see things that
doesn't work rather than it does um
having said that i guess we don't have
much time in lectures for me to do a
full debugging thing
okay so i now know that insert after
could um could create a list
and i can keep inserting people
but this time i could do interesting
things because if i insert after the
head
um i'm the head of the list so this is
going to make
whoever i put in next the second person
in the list so i'll put chicken
in as the second person in the list but
then i could do another
insertion
and i could say if i'm inserting after
the head so this is this is the
situation we're getting here
so first of all i had my head
all right there you go if i'm careful
about it and don't try to do running
writing you'll still be able to read
what it is
head was null
and then i created
a player for myself
and it pointed at null and then what i
did was
i said that the head was equal to the
one that i just created
so i go okay
head now points here and then i did an
insert after
using the head as the insert position so
the head
is now me and if i insert after me
here chicken insert after head head
is still me from the previous line
um then chicken is inserted
after me where's my paint here
so we create a new one
here
called chicken and i'm now no longer
pointing
at null because i will be pointing at
the
new node because we know that our insert
after is going to do that for us
then chicken will be pointing at the
null
we did in this code say that the head is
equal to the result
of the return of this function and so if
we want to be careful about what the
return of the function is
it returns the insert position so it
just gives back the same insert position
so if i gave it the head it gives back
the head
and it's going to be the same thing the
only time that's going to change
is or a pointer to the new list
if it had been given an empty list and
so at that point it wasn't given an
empty list
and so we can insert another person
we're doing avatar
stuff last time so we can insert ang
after that
but aang's also getting inserted after
the head
we don't need to even worry about these
because we're we're assuming at this
point that the head's not going to
change
but if angs inserted after the head that
means the head is still
me
so we've got this insertion here between
me and chicken
so first thing that will happen
ang will copy my next pointer
to point the chicken and then my next
pointer will then point at the new node
here that has been created which is ang
so we're starting now to be able to
insert things
in different orders so this then if i've
done
this in this order should print out my
name then aang's name then chicken's
name
even though you see we're doing these
things in a particular order here
because we're doing insert
after the head each time each new
insertion becomes this the
second element in the list so i became
the only element in the list then
chicken becomes the second
and becomes the second element of the
list pushing chicken one along
so let's test this gonna compile and run
it and make sure that's actually doing
that
mark then and then chicken so this
follows what i said
should happen here myself then and then
chicken because we're now
using the capability to insert in
between
other nodes in the list
okay that's probably okay for now
i say probably because i'm never going
to say something is working unless i've
tested it a fair bit but i'm pretty sure
this is working for now
so we've got the ability to insert in
between
players i think when i did this here i
did it with different code but you know
similar kind of thing now
what i said was we were going to try to
insert into a list
in a way that was going to keep this
list ordered
in some way so what i'm going to do now
is i'm going to start
comparing the names of players and
deciding where to insert them in the
list
because when you think about it one way
that we could organize this list
is alphabetically and at the moment it's
definitely not alphabetically ordered
um aang should go first and then chicken
and myself so this is like very very not
alphabetically ordered but if we do this
in a particular way we could
alphabetically order this list so what
that's what we're going to try to do
so we can look at the strings
in each node in the list we can loop
through the list
we've got both of these things we've
already learned about so if i loop
through the list
looking at the strings in um
that are in the nodes compare them
against the string that i'm just
i've just created i want to insert
somewhere in the list i should be able
to find somewhere in the list
that my node should be placed and so i'm
going to use
a string library function for this
called
stir comp short for string compare
string compare is pretty weird um
because
it compares two strings and returns
zero if they're equal it's exactly the
opposite of what i would like
for for for a sort of true false um
question because it's not a true false
question it's a zero if there's no
differences between them
and it's negative if the first of the
two things put into string compare had a
lower ascii value than the second
or it's positive if they had a higher
ascii value than the second
so when i say lower or higher ascii
value it's going to look at the first
letters of both words
and if they're the same it's going to go
on to the second letters of both words
if they're the same it'll keep going
basically until it finds a difference
and it'll show you the negative or
positive
or if it gets to the end of the strings
and they're the same we'll get the zero
out of it
um michael's answering a lot of
questions there i'm gonna leave them
with you
michael uh someone's asking about um
sorting methods we're not actually
sorting a list here
so we're not taking a list that is out
of order and putting it into order and
there's a whole field of computing which
is all about
taking lists that aren't in order and
rearranging them to be in order
what we're doing here is we're just
putting things into the list
and making sure they're in order and
then that list will always be in order
if
all every time we insert into the list
we insert in alphabetical order
so we're gonna use string compare for
this um
and finding where to insert involves
looping through the list that we already
assume is in alphabetical order
and and we're going to assume it because
everything that we put into it we're
going to put it in alphabetical order so
hopefully that's going to keep the same
order as long as we don't move anything
around we'll be fine here
so we're going to loop through and we're
going to test using string compare
and then we're going to stop at a
certain point in the loop and say this
is where we're inserting so
i'll show you in in pictures here uh
which is a nice way to to think about it
so
if i have a b d e so i've got
um the letters here and obviously the
letter c
is missing um what i want to do is i
want to compare c
against each of the nodes in the list
and then see where it should be inserted
so my loop starts at the first element
of the list loop always starts as a copy
of the head
and it compares a and c and it says a is
before c
so if a is before c then my loop should
move on um and it says
goes here and says b is before c so if b
is before c
i'm going to move on and then it gets to
here and it says d
or d is after c so if
b was before c and d is after c then i
know that i need to insert in between
those two
so the pointer of my loop is going to
stop
aimed at d and the only little issue
here is because the pointer of my loop
is aimed at d
i have a function that says insert after
i don't have a function that says insert
before because insert before is really
hard to write
because we don't have access to any of
the nodes before us in the list we only
have
access to the nodes after us because the
next pointers are all going
in a particular direction so
what i will do is i'll have
this pointer that tells me where the
loop stops but i'll keep track of the
node that was just before where i was
and i'll say insert after this node so
the first thing i do is i loop through
and i say i should be after this letter
i should be after this letter we're
going to do this with words
same thing though i'm good this word is
after this word this word's after this
word
and when we go this words before this
word i have to stop here and say insert
before this thing
which means we insert after the last
node and it goes in between these two
here's a whole lot of complicated code
let's write it instead
i just have it all in the slides just in
case people want to like really go
through and look at that
in detail but we're going to now
use some of the stuff we've already
created
like this insert after and we're going
to insert alphabetically
interesting thing that's going on here
is i'm going to part way through the
creation of this thing probably come to
the realization
that insert after is not something that
i want in my main
because i may actually not want my main
function to ever just grab
a list and insert into a particular
position into it insert after might be
one of these functions
that exists in the c file only
and doesn't get given to the other um
the other parts of the program in the h
file i'll keep working as if it is
something that we're going to keep
though and then we'll see
what we think about it afterwards
so inserting into a list alphabetically
um
i'm gonna say i think from memory
that what we're going to give back from
this function is the head of the list
so we get given the head of the list and
we're going to give the head of the list
back
however because we're doing an
alphabetical insertion the head of the
list might now be a new element
so for example if i'm inserting
alphabetically and i say mark
and then i insert chicken into that list
the head of the list is actually going
to change
because the head used to be pointed at
me but chicken will come before me in
the list so it'll be a new head of the
list
so that's what i'm my intuition says
that that's what we're going to return
is instead of returning just where we
inserted from or something like that
we're going to give back um the new head
of the list if it's changed or the old
head of the list
hadn't changed so we're definitely
returning a player
i'm going to call this insert alpha and
what we're going to do is get
given the head of the list and also um
the name
of the new player
that's going to be inserted into the
list
and so what we're going to do is it's
like you know it's quite similar to this
insert position it's definitely going to
be using the insert
after function the insert after function
is also using the create player function
so you start to see now why
we build things into functions because
each of these functions has just one job
and you build up your complexity by
going okay we're going to use this thing
as a one line in this function so that
this function is not too complicated
we use this as a one line in this
function if i had insert alpha and i
didn't have insert after or create
player
my insert alpha function would be like
multiple pages of code
the more code you stack together in one
place the harder it is to find any
problems in it
so this separates each of these things
out into their own
not a huge amount of code you know also
not a huge amount of code if something
goes wrong in one of these functions
there's not that much for me to look at
but if i tried to put this all
into one function which is the insert
alpha
function potentially could get in a lot
of trouble there
so let's go insert alpha
let me just do that so you can see it
more clearly
so it assumes the list is already in
alphabetical order
returns the head
of the list it may
have changed
okay again
this is a big function break it down
into parts so that we understand what
we're doing with it
loop through and find the
insertion point
finding my autocomplete here
so we're going to loop through the list
and we're going to remember that
the insertion point is
go past any
names that are earlier than us
alphabetically
stop when we reach
a name that is after
us alphabetically
i know that these comments are way more
than i need to describe my code
but for the moment they're what i need
so that i can write my code correctly
um
so in order to loop through and find the
insertion point
i've been given a pointer to the head of
the list
i can make a new one if i want to
um people often use
the short c-u-r-r just to be current
to short for current so current is equal
to the head of the list
we're going to loop through we're going
to do a standard while loop
on this for the moment because we know
we're actually going to have a
particular stopping case
so but we we will still
be stopping if it's null so if it's null
that means we made it to the end of the
list
and current equals
current next so i've set up my my
my while loop here by saying start at
the head
loop until the end one node at a time i
can probably put these together because
this is all just the structure of a
basic while loop
so i'm saying go past any names that are
earlier than us alphabetically
stop when we reach a name that is after
us alphabetically so i want this while
loop to stop
under certain conditions so i'm going to
say if you get to the end of the list
stop um or
oh sorry it's not at all because this is
the stopping case
oh no no it is it is uh stop if you
if you reach the end or earlier than
that
stop if the name
that we reach is after us alphabetically
so i'm just going to come up here and
make sure i've got my string.h i do have
my string.h
and i know that i'm going to compare
things alphabetically
using sturcomp
now probably even though i've defined it
on the slides
um i probably want to go through
and just have a quick look
store company there's lots of different
places where people have put information
about c
or you can say i've been there i visited
this page three times so you can see
i go back and i look at these c standard
library stuff right
um this is a point where i'm saying
yeah memorizing these things might make
things a tiny bit quicker
but um a lot of what we're doing with
these is going to be
that's awkward i've got ads turning up
in my in my lectures now
and they won't go away go away there you
go there you go
um it's nice to just know that there's
references for these things and the
standard library is not so
i'm not asking you to memorize it it's
not something that um
like sure it might help a little to
memorize it but what's more important is
to remember how to use these things
not exactly all the details so string
one first string two compared string two
second string to be compared
return value is less than zero indicate
string one is less than string two if
it's greater than zero
indicates string two is less than string
one okay so we've got that that's a
little bit hard to memorize
but let's put our two strings in and see
what where
what we're looking at so if current is
in
is not null um interesting thing
about or statements like this they go
left to right
so if my current was null
this string compare would never be run
which means that
if current is not null and then we come
in here
then we would check this um
i'm thinking this actually is an and not
an or is it
i wonder if people had already noticed
that
someone was asking if we can use the
internet in exams yes you can
and lorenzo notice that should be and
yeah so
if current was null we would just stop
here the while loop would stop so we're
going to say
that for this thing to be valid we want
for this thing to keep looping we want
us not to be the end of the list and we
want to be skipping over things so go
past any names that are earlier than us
alphabetically
so if we take the
current's name it is name right
yeah it's just name and we compare it
against the new name that we have been
given
then we want to say go past any names
that are earlier than us
alphabetically so i want the first
string to be lower in value than the
second string
first string
lower than second string return value
will be less than zero
so if the string compare
of these two is less than zero
then we will keep moving if it's the
equal or greater than zero we're going
to stop
so
i'm gonna put this in
here
i don't need that comment anymore i
think
current is now the first
player in the list with the name
higher
than new name okay so i've just got this
here so i know that the current
i know now i'm looping through if i go
back to my
images here
i've now made this loop that stops here
the trick
now though the trick that is weird is
that
if we're stopping here we need to know
this one so
zg's got a good question in there saying
shouldn't we maybe just go current next
name so if we do current next
name then we would be able to have the
current pointer here
and we can say okay we're going to use
this one as our insertion point
the only risk there is what if we get to
this node and we say current
next name so if i say this is my current
and my next is null and i try to read
the name in a null
i'm going to get what's it called a null
pointer
exception or is it a an error for
accessing a null pointer
so there are some issues there and we'd
have to fiddle with our stopping cases
and stuff like that
so yeah lorenzo's saying the same thing
like what would what would happen if it
was that
so so that's one issue but yes you could
definitely do it that way
you just have to play around with your
stopping cases to make sure you never
actually get to this node
the only problem is what if i wanted to
insert f into this i do actually want to
reach this node
and then insert there so i'm going to
use a different trick
for this which might be a little bit
easier
but it's got its own complications but
i'll show you how it works
what i'm going to do is i'm going to
create a node
that is the previous node in my list
so it's going to start off as null
because if i'm at the head of the list
there is no previous node
but then what i'm going to do is i'm
going to say
previous is equal to current and then
current is equal to current next so
i'm gonna have a look at this okay so
um let's go
um current
is pointed at the head and what's
another color i can use
i'm kind of running out of colors
and previous is pointed at null
then i go through my loop and i say
in the loop previous is equal to current
then current is equal to current next so
first previous is equal to current
current's pointing at mark so previous
is equal to current
says previous is now pointing at mark
and current moves on to current next so
current is mark mark's next points of
ang
current becomes uh
pointing at ang instead so we go current
moves on what color was that using there
so what we now have is previous is
pointing at the last one
current is pointed at the current one
and then if we moved on again
previous would copy current and move to
aim current would move on
to chicken so what we're now doing is
moving two pointers along a list
so we've got the the pointer that's
actually testing things and the pointer
that's trailing behind and going okay
this is the one that was born before
where we were testing um you could
definitely go
okay let's move the current along and
test things ahead of ourselves
but what i'm doing is i'm testing at
where i am and just trailing a pointer
behind me because it's not going to cost
me that much to trail a point to behind
me
it's just maintaining the pointer and
saying
wherever i go this thing goes to where i
just was
i where i just was yeah it's like am i
still speaking english or am i now
speaking code
so the previous follows the current and
then the current moves on
to the next thing so current is now the
first player in the list with the name
higher
the new name i'm going to be specific
about this here
previous is now the
um last player
in the list with a name
lower
than your name i don't know if it's
exactly lower it might be lower than or
equal to because of this
do we keep going if they're equal no we
only keep going
this is higher or equal
yeah so that's higher equal so obviously
these are more comments than i would put
in a normal piece of code but
um while we're learning about things
this is kind of handy so
this is the loop through and find the
insertion point this is probably the
only comment that i would have actually
left in there normally
because it's like if you read that you
could ignore all of this code and know
what it was doing so
loop through and find the insertion
point so now that we've found the
insertion point
insert um at
this insertion point
luckily inserting there is not too hard
because we have a function that says
insert after so i can insert after my
previous
so i can say um
insert after the
previous pointer is the thing that we're
going to be inserting after
and we're inserting the new name which
is the same name that we were given
right perfect good done
you know right you know right if i
if i if i say um if i say perfect good
done then you know there's an issue
lorenzo is saying something though
shouldn't it be higher because we want
to keep going until the second
is higher so let me see if i've done
this correctly so i'm saying
keep going if new name is higher than
current name
let's go back to our
thing here and say returns less than 0
if
string 1 is less than string 2.
so i'm going to say keep looping
if if this name is less than this name
so i'm saying don't stop the loop
if um
if the current name that we're seeing so
the name we're seeing
is a lower name than the name we're
carrying
i think this is okay because
um it will keep going
if the current name is um if the name
we're seeing in the list
here so we're comparing these two and if
this is lower we keep moving
um and then there's a point at which
maybe if there was a c in this list we
would move past the b and we'd stop on
the c
so we're inserting i think it is
the last plane this is lower the current
is higher or equal
yeah i think this is it
so oddsmart asks an interesting question
what about alphabetical ordering of matt
and mark so we're relying on string
compare to do this for us so string
compare is going to look at the ms
and say you're the same then it's going
to look at the a's and say you're the
same
and then it's going to look at the r and
the t and then it's going to compare
those two and that will be the
difference
oh yeah michael's already answered that
yeah so it will go through letter by
letter
where we're just allowing string
compared to do the hard work for us so
that we don't have to
okay so we're going to insert after this
and we go okay that's fine
so let's look at the possible situations
we could have here
if we're anywhere in the list and we
insert after we're probably okay
but we did have this situation where
insert after could be inserting into an
empty list
insert alpha could also be working on
empty lists
so if we have an empty list the head is
null and the previous is null
insert after null
is going to give us back
pointer to the new thing so we need to
deal with two situations we need to deal
with
if we're inserting into a list that
already has
elements or we're inserting to a list
that's empty
and then when we think about this as one
other situation we may have to think
about which we haven't really
is
inserting at the head of a list because
if we're inserting at the head of the
list we have the same kind of situation
where
if we're inserting after previous and
previous started as null
then we're always going to have some
issues there so if previous was null
or head was null then we're going to try
to insert
into a null here we do have code that
deals with that
but we still need to be aiming at this
return
return to the head of the list if it's
changed so if the head of the list was
null
we need to return the new head of the
list which was
um uh which is the new
element that we've just inserted so
we're probably going to want to
say um
i don't know what i want to call this um
i don't think that's a good that's not a
good name uh
maybe i'm looking at res insert result
here
is in inserting after the previous but i
have several different cases here that i
might need to deal with
i might get away with treating these as
the same
so if i'm inserting into an empty list
or i'm inserting at the head of the list
let's try treating them as the same
thing and see how this works so
inserting the head of the list i need to
ask if i'm inserting at the head of the
list
how do i know if i'm inserting at the
head of the list let's look at the
conditions
current's ahead of the list if previous
is null
then we're in the situation where we
haven't started looping yet
so if the string compare
here causes us to stop immediately
or the current was null then i know that
this will never run so
previous will remain null so i could say
that
if
if the previous is null then i'm
inserting at the head of a list
so if i'm inserting at the head of the
list i would probably do the same thing
insert but then i would get this insert
result
so what i might do is do this first
so i've got my insert result and i've
inserted after the thing
if the previous was null then i know
that my insert result is now
a pointer to the element i just inserted
which means that the
head of the list is now
the insert result
and i know that what i'm going to do at
the end is return the head
so if i'm just inserting normally
somewhere
into a list this comment's probably not
correct now
i'll just get rid of that and decide
what i want to say about that later
so i try to insert after previous
if that insertion had been into a null
then it becomes the new head of the list
however this doesn't necessarily
tell us if there were more elements in
this list or not
and what i've done is i've just replaced
the head which is probably not a great
idea
either let's let's let's draw a picture
of the different possibilities of
situations that we could be in
so one situation that is reasonably
easy for us to think about is
oops
head points at null
empty list if i'm inserting
alphabetically into an empty list i
become
the only element of the list which is
let's just say i am a
um i will be pointing at null
and then the head will be pointed at me
wrong color but you get what i mean okay
so this is okay where i say
if the previous was null i'm inserting
at the head of the list
and then the head will become that
insert results
so that there i have another possible
situation though
what if
we've got a few of these
and let's say this was um
named x and y and i insert
a into this list
now i do know that my head is definitely
going to want to end up
pointing here but i also know that this
connection needs to be made
for me to be connected to the rest of
the list so if i just say
head is equal to the insert result i've
replaced the point of the head
here if i do that
then i'm in this position here
and i have literally lost what's in this
list
here because i didn't maintain
connection to that so what i need to do
is
if i'm at the head of the list
i can take my insert result which is a
player
and i can say their next pointer
should be equal to the head so what i'm
saying is i'm connecting to whatever's
the head of the list and this works even
if it's null
so even if it's null what i'm saying is
like your next is null it might already
be null
but it doesn't matter because there's a
chance that it won't be null so what i'm
saying insert results next is equal to
head
so what i did there was let's
go back to this position here
i've inserted this at the head of the
list it's next
should be the head so it's next
points at the same thing the head points
that and then after that
i change the head to be pointed at my
new head of the list
like so it's pretty complicated
but this gets us the example where if i
insert at the start of the list
or i insert an empty list this will work
here
because what happens is i will do my
insertion
and i'll get an insert result out of
that that insert result
can is is definitely going to be the new
new head
but if it's the head of a list that
already exists we also
need to reconnect it with the rest of
the list that's there
ah william good question surely there is
a library that handles all this code for
us
unfortunately in c there is no linked
list library but in many other
programming languages there are
um lists like this this is
actually one of the reasons why we teach
c because the
uh this depth of understanding of how to
do the memory allocation moving the
pointers around and stuff like that
we consider something really useful
because when the library doesn't work
for you
you have to write your own code so in
this simple case yeah we could probably
make libraries that work for us
but when we start fiddling around with
these things and trying to make custom
things and stuff like that
it's really good to know how they work
underneath yeah
so um what we've done here
let's go back through what we did we
found our insertion point
um by looping through and finding the
point where we wanted to insert
something
we then went back one pointer in a sense
using our previous pointer here
to decide where the insertion point was
then
we do our insertion um
so we insert after the previous with the
new name we know that insert
after is going to deal with the creation
of these things the memory allocation
and stuff like that
also we're leaking memory in this
program we haven't done any freeing at
all we're going to do that
on friday because we don't have enough
time
so the insert result is either going to
just be
the um the position we inserted into so
it's going to be a copy of the previous
pointer
or it's going to be something different
if it had to insert at the start of the
list
and so we can check that by saying did
we insert at the start of the list
if we did we do a little bit more
accounting to make sure that a
the list is still connected to the rest
of it and the head becomes the new
insert result so let's test this
and see how it works here so instead of
insert after we're going to insert alpha
so what i'm hoping for here is the head
is null
and if we insert alphabetically into the
head i will just be
the only element there then we say
the head is the result of inserting um
chicken into the list chicken should now
be the first element of the list so she
will be the head of the list and i will
still be in the list
and we do the same thing for aang so
what we should get is ang first then
chicken then me
but let's see whether this works or not
so i'm going to compile that and run it
we have ang and then chicken then mark
what might be interesting
is to
print out in between each of these
things
um
i'm just going to need a
standard input output library so that i
can do
some other stuff here
i'm just going to put some gaps in
between each of these printouts
so we can see the difference oh actually
i'm just going to copy that
so we're going to see the different
steps so will i insert my name
i should be the only one in the list and
then there'll be a gap
after i insert chicken into the list
then she should go first and then me
and then afterwards and should also end
up being the start of the list
although let's um let's try to add
someone in the middle of the list as
well so we're testing multiple different
things
so this is inserting into an empty list
this is inserting as the head of the
list
this is inserting somewhere in the
middle of the list
so let's try this compile this
and run it so oh i should have put a new
line on that
let's let's compile and run that again
and see how it goes
okay so the first thing is me and then
when i inserted chicken alphabetically
into the list
she came into the list before me so she
goes first
and then i uh i add goku to the list
and we go through the list and it's
going to go all right goku's after
chicken
goku is before mark so we're going to
insert after chicken
so goku goes after chicken in the list
and i get pushed one along
and so now we have a way of adding
elements to the list
that is always going to be alphabetical
so it doesn't matter how many people i
add to this list we're always going to
get
an alphabetical list out of this because
the the function is assuming that things
are already alphabetically ordered
but they kind of are because an empty
list is alphabetically ordered
a list with only one element is
alphabetically ordered and then if we
keep adding using the same function
it just keeps things in order
so yeah that's the
the fiddliness of doing insertion
into linked lists as well as looping
through to find an exact position there
so i'm pretty much out of time here um
i will wrap up the lecture as it is
now but i'll come back in a second and
answer questions if anyone has any
questions
and wants to know more about what's
going on here and wants to maybe get me
to dive into some of the code there and
have a look at it and draw some more
pictures and stuff like that
so i'll wrap up the lecture here we're
not actually done with this example as i
said before
we have not um did i oh no i didn't put
any more slides there
we haven't removed anything from the
list and we haven't dealt
with um freeing of memory and stuff like
that so that's going to be the third
lecture in the linked list
series we're going to go into that okay
so um i'll wrap it up there
and i'll go into break mode and i'll
come back in a second and
answer any questions people have about
things
oh hang on alan was asking for the live
code oh wait it's here
i'll copy this
and there's the there's a link to the
live code sorry i should have put that
in chat earlier
all right i'm going to wrap up the
lecture there
um and i will come back in a second and
answer any questions that anyone has
alrighty i am back um so we had a bit of
a bit of discussion in there
after i just popped out then uh
interesting things ollie's talking about
when the program ends it frees the
memory yeah so the operating system is
going to claim back
the memory when the program finishes
running so for our things here it's not
that big a deal
um because we run it and ends straight
away however
i'm not about to about to just start
teaching people that like don't worry
about memory because your program's
going to end and everything's going to
be fine
because we saw before that if i had a
particularly aggressive memory leak in a
loop
um that um leaking memory program that i
ran was
how long did that last like 20 seconds
and then it was done
um this you know the majority of the
programs that we use day to day we're
going to use them for a lot longer than
20 seconds at a time
rare to see that aggressive and memory
leak but um
you get something like i think michael's
talking about browsers right they're
gonna
they're gonna be running for hours and
hours and hours of the time
and you're always gonna be loading new
things and then removing them loading
new things and removing them
some of those things are huge you know
like
streaming two hours worth of a lecture
on youtube
if you are leaking memory for for every
kind of few seconds
of video your your computer would run
out of memory very quickly
um other things like your operating
system that might be on for days
at a time um it's it's kind of bad for
them to have memory leaks because
they'll slow down your computer
chrome is a very interesting example
because it's not actually
leaking memory but chrome is very
aggressive
with memory so in order to make your
tabs pop up really quickly it keeps a
lot of them in memory
and the raw amount of data on any
particular website might be a huge
amount of information
embedded videos adds a whole lot of
images and stuff like that they take up
a lot of space
and so chrome says people tend to like
it
when when chrome's really responsive so
if they're going to keep 500 tabs open
i'm going to actually try to keep all
500 tabs
in memory and obviously your ram just
disappears when that happens so it's not
necessarily leaking at that point it's
just
it's just using all of that memory with
the idea that you might want to switch
to one of your 500 tabs
which in general is why i say to people
having 500 tabs open might be an issue
i like to keep mine pretty small so i
don't i don't usually have more than
about 20
tabs open at a time but depending on the
complexity of the websites you're
looking at still could use a lot of
memory
anyway that's a that's a little aside i
actually don't know
though i haven't done a memory analysis
on chrome to see if it's leaking or not
but but that's what i know of the
the general design principles behind
something like um
google chrome the linux operating system
does
a lot of similar stuff like that where
um
well i don't know if it does nowadays
but years ago it used to do this thing
where it was like
if you have ram that you're not using um
it would use it
it would be like look we're going to
have a rough
it's really rough prediction of the
things that people might want to use
and we're going to put them into memory
ahead of time so there's a good chance
that if you
you try to do something or your programs
move on to the next step
um that it's already in memory and ready
to go as opposed to just leaving it
empty
and saying when you try to run something
you've got to copy it from the hard
drive into the ram and then run it
which is a slow step because the hard
drive when you think about like we call
them orders of magnitude of speed
um the hard drive is like a thousand
times slower than memory
memory is a thousand times slower than
the registers on the cpu
so i showed you that kind of hierarchy
of hardware right
if you don't have to dip down into the
slower parts of the hardware
then everything kind of runs quicker so
some
some things will get aggressive like
that so chrome's getting aggressive like
that and saying
with all this stuff i could put it onto
the hard drive
and it's safe there it's fine and when
someone asks for it i'll grab it off the
hard drive
but then when you click on that tab and
it takes like two seconds
to load all that stuff from the hard
drive into the memory and then from the
memory into the cpu
to run it us as humans notice humans are
actually very reactive we notice
anything shorter than about a thirtieth
of a second
so anything less than that we're like i
don't like to wait for that feel
sluggish
you know so sometimes those programs and
operating systems will get aggressive
with memory
so that that tiny delay doesn't happen
it takes a lot of work to actually write
operating systems to make them do that
um but we kind of notice as humans and
so we like it
like anyone who's been using vlab from
overseas or even just on a like
mildly um slow internet connection
because vlab is like giving you the
entire image
of a screen that's rendering somewhere
else um
so there's always going to be lag in a
system like that
um and it doesn't take much for you to
notice and start to be frustrated with
it
so that's like one of the one of the
difficulties with us trying to provide a
consistent
environment to everyone through vlab is
it's very bandwidth hungry and
and it triggers that kind of noticeable
delay
effect in humans um
okay so uh william was saying that g
lib.h handles linked lists and stuff so
this is really funny and i think it's
really interesting that
i don't often look up libraries that i'm
not using and knowing that i'm going to
be teaching
linked lists and teaching people how to
really build them from scratch and stuff
like that i've never actually bothered
to look up
the libraries that would do this for us
for free because i know that like you
know
educational goals is to get people deep
into this stuff
so it's kind of like um
in order to understand how this stuff
works at a at a higher level
we must work at it at this level and um
and and have to learn even though
there's a library that does it for you
so it's interesting i will check out the
library though because it could be
interesting
um
art smart said something that michael
was gonna pass along
oh the zip file on the assignment two
page is unavailable to download
oops we'll deal with that thanks for
that
okay so did anyone have any questions i
know that we went through
ironically we didn't write very much
code
but it was very very complicated code so
if anyone has any questions about the
code that we wrote
um today um please
uh type in questions now and i can go
back over things and look at it
i think that a lot of the time you know
because i i've taught this before a lot
of time when we hit this lecture
or in amongst these linked list lectures
um
generally what happens is i show stuff
it's exceedingly complex a lot of brains
explode
and people don't necessarily have
questions until
um after a re-watch of this
where they have to re-watch and pause it
and just go what did he actually mean by
that let's look at this let's maybe draw
some pictures
and stuff like that and make it happen
because it's funny like
a function that is only what are we 15
lines long
here and and half of those comments um
normally we'd think about this and say
this isn't too hard we can understand
this
but when you start using pointers
everywhere
for everything it it i think it takes a
little bit more effort to figure out
exactly what's going on
so um feel free to ask questions now if
anyone's got any but it looks like
we've been here for a while without any
questions coming up
so i'm just excu assuming for the moment
that um brains are exploding and we're
going to need to spend some time in
tutorials playing around with these
um working on the labs and the
assignment and stuff like that
and then the questions will come up
later so maybe next week
um when well not next week sorry on
friday when this
example is complete um people
will want to dive more into specific
things
these linked list examples are also
very very specifically um
similar to some of the stuff that's in
the assignment as well so hopefully this
stuff will help with that they're not
exactly the same
like as i said i'm never gonna exactly
do the assignment for you but a lot of
stuff that's similar to it might be
handy
um uh lorenzo's saying that multi-file
projects were worse
than linked lists so that's good so i
think sometimes like
the multifile projects is like a it's
like a configuration thinking
sort of things like how do we piece
these things apart so that
um so that humans can use them whereas
um
linked list thinking is very much more
abstract to mathematical thinking
so maybe lorenzo you've got more of a
you're happier with the abstract
mathematical side the problem-solving
side of things
actually both of those are
problem-solving rather than the kind of
re-engineering um things for
for human use which is like the uh the
multi-file project side of things
um m stephanie who's saying i wish i
watched this lecture before starting on
assignment two
i was hoping that like um the the
example from the first assignment where
it was like you don't really have to
start the assignment until
um until after the first week
that it's released because tomorrow
we're also doing a live stream four to
six pm tomorrow
i'm bringing tom in again for this one
to talk about the assignment and answer
any questions people have about the
assignment and stuff like that
i mean having said that um you're still
like way ahead if you started the
assignment already i don't think that
many people in the course have started
the assignment because it's been out for
am i am i thinking 24 hours or even less
than 24 hours the
the final not the the final
non-draft version of the assignment has
only been out for like 24 hours
so i'm really happy that you've started
actually but
you could if you wanted to don't do it
but if you want to you could delete all
your code and start again
at this point and you'd still have
plenty of time to finish things
um blake is asking
spoiler alert blake would you use these
lists for stacks and queues
um huge spoiler week nine lecture one
we will use these for stacks and queues
we're not necessarily going to go too
deep into queues but we're definitely
going to i'm going to show you stacks
because stacks are such a programming
thing
so we're going to talk about what stacks
are and we're going to use something
like a linked list
to um to actually implement a stack so
yes it's coming um
and i always love it when someone says
would you use this for this or
or is the follow-up for this this and i
was like yes it is
and it's in the lectures and it's in my
plan already which means
it makes me happy because it means that
my plans for how the course
goes from one thing to the next is
intuitive and it follows
um brendan's saying 100 some people have
already finished it
wow some people are bored
it's funny because i haven't i know
someone
i can't remember who wrote it i think
tom wrote the reference solution
for this one but i can't remember for
certain
but yeah i haven't actually gone through
and implemented it but i mean i often
won't implement everything that's in the
course
it's like i definitely implement
obviously lecture code and heaps of the
tutorials and labs and stuff
um actually not all of them are mine
only about
maybe less than a quarter of the
exercises in their
stuff that i wrote um but um
yeah so it's interesting that people are
already
jumping into it um which is fun but
don't worry if you
if you aren't jumping into it because as
m stephanos saying that that
maybe this would have been easier after
these lectures
so after the linked list series which
ends on friday
and also especially after the live
stream on thursday which is specifically
assignment based
a lot of people i think would wait for
those two and then start
on the weekend or something like that
and that actually is a fine
way to start the assignment i would say
read the assignment spec before thursday
so that when we're talking about it in
the live stream if you want to come
along
you can ask questions and stuff like
that um
and blake's saying yes do they have to
be doubly linked for queues
we're not specifically looking at doubly
linked lists
in this course so you can if you want to
and this is if anyone's wondering
this is the concept that we could have
[Music]
this
so we can have pointers going back and
forth
between nodes if you think about this
if we had set up a list with the
pointers going back and forth
our code here would have been
easier because we would never have
needed to set up
this previous pointer every node itself
would have a previous pointer
having said that linked lists are
complex enough as it is without us
adding another extra thing to have to
set up
and modify so all of our insertions and
removals
get more fiddly if we have to change
multiple pointers and stuff like that
so we haven't been doing them um
they can help in certain things so if
you need to go backwards through a list
it helps to do this we're doing it with
just one set of links
so that we can just loop through in one
direction
if we need to find something we could
start a loop again and go through
um because we kind of want to hit this
at the most fundamental level
uh rather than trying to do a more
complex version of it
and then ending up and you know
confusing people
so i think they're they're complex
enough as it is with the
single linkage but if you do
want to do if you do find a reason
to make a doubly linked list so there
might be
some lab exercises that make it
interesting to use a doubling link list
there also might be parts of the
assignment where you say huh
if i was to go both ways on
on this linked list it might make some
things easier
so you can do it i should also point out
that the entire
assignment is designed without it so we
designed it
built it um did the reference solution
without ever needing
um pointers going both directions in the
list however if you're interested in
trying it i think it's definitely worth
you know i'm never gonna i'm never gonna
say to a student
that's a very interesting concept but
you shouldn't do it right like i'll
never say that i think if you find
something interesting and you go
i could find a use for this then
definitely go for it
um because um because you could learn
something interesting
out of it but if you're looking at it
and you say that looks too complex
i think i'm going to make mistakes with
this because it just raises the
complexity level
a bit then then i would say to you yeah
go with your gut
you don't necessarily have to add these
things also why i'm not teaching them
yeah okay um
looks like we haven't got any specific
questions about the code or anything
like that
so i'm going to assume that everybody
understands it fully and can replicate
it in a moment's notice
that's mean i don't believe that yet i
usually think that
people are going to need to um
work through these things which is why
they're in the labs
for this week and next week and then
you'll go through and you'll get more of
an understanding of what's going on
stuff is getting a little bit compressed
now as we get close to the end of term
in that i know that
we can't have a lab after week 10 so the
week 10 lectures
um i'm basically not really introducing
any new content in the week 10 lectures
because there's no way to reinforce it
in the lab and like week 8 has the lab
and then at the lab in week 9 and the
week 9 has the lab in week 10 so
we're kind of running out of uh
a lot of kind of time to do multiple
exercises
and stuff now that we're nearing the end
of the term so hopefully there's enough
there
um and there's also a week after which
is like the week 11 where people will be
studying for the exam and stuff like
that
i'll try to do a live stream that week
as well so that i can actually
um answer people's questions if people
have last minute questions and stuff
like that
blake has one question about string
compare is it just returning one
zero or negative one or does it return
the magnitude of the difference
um that's a good question
and one that i have really looked at
but i'm pretty sure that
it will be i'm pretty sure but 100 sure
i think it's like a
measure of the ascii distance
between them having said that let me let
me throw this back to you
like to try out um because this should
actually
not be a super difficult piece of code
to write
where you could say um like this example
code here with two strings
um and the cases as
actually because string compare is using
um what's gonna call it um ascii values
so it will actually say that lowercase i
think is earlier in the alphabet than
uppercase i have to look at the ascii
table to see that
um if you want to you can do the string
compare
get that to go into an integer and print
out that integer and say
these two strings are this far apart and
try punching in a lot of different
strings
and seeing what the difference is
because i don't think you can just
get a number out of this because if you
got a number you could you could measure
the ascii distance between two
characters
as a number but between two strings it's
kind of like
is the first letter more significant
than the second letter and if it is more
significant should have
should it have a different value or
something so it's really hard to say
what that number should be but i think
this would be cool one so if you want to
um create some code that
um that actually records that number and
sees what the difference is and printed
out
and see if you're getting anything
beyond just a one or a zero
or if you're getting literal ascii
distances between things
because i think that might be
interesting to look at um i haven't done
it
because um i tend to
to just use it as a more of a yes no
thing than
a um then a specific distance between
things
all right i might wrap it up there um
blake please let me know how you go with
that
maybe tomorrow's stream or friday's
lecture you
can you can um let us know how string
compare works because friday's lecture
we're going to use string compare again
so that would be a good time to say
well did some oh right you've just done
it there
with a and z and it returned to negative
one
so it's actually only giving you a
difference between things
or try it with longer things
than a and z like aaa and zzz
or a a a and a
a z and see if it has to go further into
characters
if it returns something other than
negative one i'd i'd be interested to
see that
i mean actually the time i've been
talking about this i could have written
the same code
that you have but i thought you know you
know as a teacher
you try to convince your students to do
the investigating because it's more
valuable for you
ah okay so it's really only giving us a
negative one or a positive one
okay so it's not measuring distance it's
just measuring
if there is a difference rather than how
far that difference is
good to know interesting to learn these
things okay
i'm going to wrap it up there thank you
everyone um hopefully the
link lists and multi-file projects and
stuff like that aren't breaking people's
brains too much
um and you will have some you'll have
plenty of time to get acquainted with
these
uh over the course of the second
assignment anyway all right
see you all tomorrow if you're coming
tomorrow to the assignment live stream
otherwise friday for the lecture then
catch
